<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>CPython中的多线程、GIL与锁 | 哪吒的莲花座</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CPython中的多线程、GIL与锁</h1><a id="logo" href="/.">哪吒的莲花座</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CPython中的多线程、GIL与锁</h1><div class="post-meta">2020-12-12</div><div class="post-content"><p>刚接触python的threading的时候小朋友有许多问号，听说了有GIL，于是上手写了两个线程测试了一下，用sleep进行了两个线程的延时，结果发现两个线程在多线程情况下的确速度比单线程情况快了一倍，怎么回事？！说好的GIL去哪了？！小朋友有更多问号了！于是查阅了各方资料试了不同的代码终于算是差不多理清了~</p>
<a id="more"></a>

<h2 id="预备概念"><a href="#预备概念" class="headerlink" title="预备概念"></a>预备概念</h2><p>首先复习一下需要的各个概念。</p>
<ul>
<li><h5 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h5>全局解释锁。CPython中的机制，确保同一时刻只有一个线程在运行，多个线程抢占式多任务处理。给整个解释器加锁使得解释器多线程运行更方便，其代价则是牺牲了在多处理器上的并行性。<strong>保证的是原子操作的安全性。</strong></li>
<li><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5>资源分配的最小单位，系统中正在运行的一个程序就是一个进程。拥有独立的地址空间，进程之间相互独立比较安全，但是进程间交换资源需要进程间通信。<strong>适合CPU密集型操作。</strong></li>
<li><h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5>程序执行的最小单位，每个进程至少会有一个线程，也可以有多个线程，线程之间共享进程的内存空间。每个线程拥有独立的寄存器和堆栈空间，需要频繁创建销毁切换时比进程高效，但是一个线程死掉整个进程就会死掉<strong>适合I/O密集型操作。</strong></li>
<li><h5 id="CPU密集型（计算密集型）"><a href="#CPU密集型（计算密集型）" class="headerlink" title="CPU密集型（计算密集型）"></a>CPU密集型（计算密集型）</h5>系统的硬盘、内存性能比CPU好很多，大部分时候是读/写(I/O)(硬盘/内存)在短时间就能完成，而CPU还有很多运算要处理，即读写要等待CPU Loading.</li>
<li><h5 id="I-O密集型"><a href="#I-O密集型" class="headerlink" title="I/O密集型"></a>I/O密集型</h5>CPU性能比硬盘、内存好很多，此时大部分状况是CPU在等I/O的读写操作</li>
<li><h4 id="threading-Lock"><a href="#threading-Lock" class="headerlink" title="threading.Lock"></a>threading.Lock</h4>threading模块中实现原始锁对象的类。一旦一个线程获得一个锁，会阻塞随后尝试获得锁的线程，直到它被释放。作用在当多个线程操作同一个全局变量时保证全局变量在某个线程中被使用时值不会被另一个线程所改变。<strong>保证的是python代码层面的操作安全性。</strong></li>
</ul>
<h2 id="CPython中的GIL"><a href="#CPython中的GIL" class="headerlink" title="CPython中的GIL"></a>CPython中的GIL</h2><p>讨论到GIL的作用，首先要从我开头讲的第一次“失败尝试”开始。<br>因为CPython中的多线程其实是“伪多线程”，GIL保证了多线程在实际运行时一次只有一个线程在运行，多个线程轮流执行，所以如果在python中同时开启两个线程执行（多线程）和两个线程按顺序开启执行（单线程）最后的运行时间应该是几乎一样的。甚至因为多线程涉及到线程的上下文切换，最终的运行时间可能比单线程顺序执行还长。于是我尝试了如下代码：<br>多线程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threadJob</span>():</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    start = time()</span><br><span class="line">    thread1 = threading.Thread(target=threadJob)</span><br><span class="line">    thread2 = threading.Thread(target=threadJob)</span><br><span class="line">    <span class="comment"># 多线程</span></span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line"></span><br><span class="line">    thread1.join()</span><br><span class="line">    thread2.join()</span><br><span class="line">    end = time()</span><br><span class="line">    print(end - start)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>将main函数改成单线程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    start = time()</span><br><span class="line">    thread1 = threading.Thread(target=threadJob)</span><br><span class="line">    thread2 = threading.Thread(target=threadJob)</span><br><span class="line">    <span class="comment"># 单线程</span></span><br><span class="line">    thread1.start()</span><br><span class="line">    thread1.join()</span><br><span class="line"></span><br><span class="line">    thread2.start()</span><br><span class="line">    thread2.join()</span><br><span class="line">    end = time()</span><br><span class="line">    print(end - start)</span><br></pre></td></tr></table></figure>
<p>执行时间：<br>单线程：<code>2.002271890640259</code><br>多线程：<code>1.0023510456085205</code></p>
<p>?????<br>说好的GIL呢？说好的运行时间一样呢？怎么最后还是一个1秒一个2秒？<br>于是满脸问号的我把线程执行的target改成了通过执行大量计算来延长运行时间而非使用sleep：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threadJob</span>():</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10000000</span>):</span><br><span class="line">        i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>再看执行时间：<br>单线程：<code>2.22700834274292</code><br>多线程：<code>3.174870252609253</code><br>这时就对了，多线程的执行时间甚至比单线程还要长一点  </p>
<p>为什么会出现这样的区别呢？这是因为GIL是抢占式多任务处理，存在多线程时获得GIL的线程会连续执行一段时间（Python2.x为100行指令，Python3.2之后为5毫秒默认值），之后被强制释放GIL，存在的多个线程按照优先级重新抢夺GIL，如果多个线程执行的都是计算操作，则每个线程都是等待时间片跑完后轮换执行，故所需要的时间都为顺序执行完所有计算操作的时间总和。</p>
<p><img src="/2020/12/12/CPython%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81GIL%E4%B8%8E%E9%94%81/GIL.PNG"><br>（详细内容可见<a target="_blank" rel="noopener" href="http://www.dabeaz.com/python/UnderstandingGIL.pdf">http://www.dabeaz.com/python/UnderstandingGIL.pdf</a>）</p>
<p>但是sleep()操作与计算操作使用CPU不同，<code>sleep(secs)</code>表示此线程阻塞secs的时间，主动让出GIL的控制权，直到sleep结束再重新根据优先级抢夺GIL，所以当上述两个Target中使用sleep()时，多线程相当于同时等待了两个线程的sleep并且先后结束sleep完成线程的执行，所需的时间约为一次sleep的时长，而单线程需要分别等待两次sleep，时间为多线程的两倍。</p>
<p>从这里也可以看出为什么多线程适合于I/O密集型操作。I/O操作和sleep()操作类似，当一个线程进入sleep或者等待网络I/O时，都会释放GIL让其他线程获取GIL开始运行。而当程序只有一个线程时，当程序进入sleep或者等待I/O，整个程序就会进入阻塞而不能进行其他操作，若操作过程中有过多的I/O操作就会拖慢整个进程的运行速度，此时多线程就能在等待的过程中去进行其他的运算操作从而提高效率。</p>
<p>我们再用以下函数看看GIL中线程的轮流执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threadJob</span>(<span class="params">num</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;\nThis is a tread, number is : &lt;%s&gt; \n&#x27;</span>%num)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> i % <span class="number">50000</span>:</span><br><span class="line">            print(num, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;\nThread %s is done\n&#x27;</span>%num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    start = time()</span><br><span class="line">    thread1 = threading.Thread(target=threadJob, args=(<span class="number">1</span>,))</span><br><span class="line">    thread2 = threading.Thread(target=threadJob, args=(<span class="number">2</span>,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多线程</span></span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line">    thread1.join()</span><br><span class="line">    thread2.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单线程</span></span><br><span class="line">    <span class="comment"># thread1.start()</span></span><br><span class="line">    <span class="comment"># thread1.join()</span></span><br><span class="line">    <span class="comment"># thread2.start()</span></span><br><span class="line">    <span class="comment"># thread2.join()</span></span><br><span class="line">    </span><br><span class="line">    end = time()</span><br><span class="line">    print(end - start)</span><br></pre></td></tr></table></figure>
<p>多线程输出：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">This is a tread, number is : &lt;1&gt;</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">This is a tread, number is : &lt;2&gt;</span><br><span class="line"></span><br><span class="line">1221211212212121221212121112212112121221212211212121212121212121212121212122</span><br><span class="line">1212112211221221121212212112212121221122112121212121212121212122112211221212</span><br><span class="line">1221212122121122112121212121212212121122121122112212121121221212121212121212</span><br><span class="line">2112212112121212121212212121212121212121211221122121212122121122112122112212</span><br><span class="line">1212121212121212121212121212121212121212212121212121212121211212211212212121</span><br><span class="line">1212121212121</span><br><span class="line">Thread 2 is done</span><br><span class="line"></span><br><span class="line">111111</span><br><span class="line">Thread 1 is done</span><br><span class="line"></span><br><span class="line">5.042520999908447</span><br></pre></td></tr></table></figure>

<p>单线程输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">This is a tread, number is : &lt;1&gt; </span><br><span class="line"></span><br><span class="line">1111111111111111111111111111111111111111111111111111111111111111111111111111</span><br><span class="line">1111111111111111111111111111111111111111111111111111111111111111111111111111</span><br><span class="line">111111111111111111111111111111111111111111111111</span><br><span class="line">Thread 1 is done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This is a tread, number is : &lt;2&gt;</span><br><span class="line"></span><br><span class="line">2222222222222222222222222222222222222222222222222222222222222222222222222222</span><br><span class="line">2222222222222222222222222222222222222222222222222222222222222222222222222222</span><br><span class="line">222222222222222222222222222222222222222222222222</span><br><span class="line">Thread 2 is done</span><br><span class="line"></span><br><span class="line">2.320594310760498</span><br></pre></td></tr></table></figure>
<p>由上述运行结果可见，单线程会依次执行完两个线程，执行总时间通常小于等于多线程执行时间。</p>
<p>多线程会轮流执行，但不是严格的交替执行，每次的输出结果也不完全相同，其原因在于：</p>
<ul>
<li>多个线程加入的时间有先后，可能在后一个线程加入之前前一个线程已经执行了一段时间的代码</li>
<li>线程的执行速度不是完全平稳的，每个线程每运行5毫秒就会被强制放弃GIL，在这5毫秒内所能执行的代码量不完全一致</li>
<li>每次线程的运行时间不同影响了它的优先级，导致最后根据优先级进行的线程抢夺具有随机性（更加体现在两个以上的线程）</li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁指的是threading模块中原始锁对象的类threading.Lock (L为大写)，通常用于在多线程中保护全局变量的线程安全，使得全局变量在进行完某项操作前不被别的线程所修改。这里要与GIL全局解释锁相区别。GIL保证的是原子操作的安全，而代码层面的安全是无法保证的。如果要保证全局变量在一系列操作中按所设想的顺序被操作，就需要在一系列操作时用锁将全局变量锁起来。</p>
<p>下面就运行程序来看看不同加锁方法的区别：</p>
<p>创建两个具有不同操作的target函数，各自用在10个线程中，依次为线程编号，把编号作为参数传入target中用于输出，并将这总共20个线程交替存入线程列表同时开启：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        t = threading.Thread(target=addNum, args=(i * <span class="number">2</span>,))</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t = threading.Thread(target=addNum2, args=(i * <span class="number">2</span> + <span class="number">1</span>,))</span><br><span class="line">        threads.append(t)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        threads[i].start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        threads[i].join()</span><br><span class="line">    print(<span class="string">&#x27;\nnum: &#x27;</span>, num)</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>主线程准备就绪，我们依次来看看target不同的加锁方式之间的运行差别：</p>
<h3 id="1-不加锁，只依靠GIL"><a href="#1-不加锁，只依靠GIL" class="headerlink" title="1. 不加锁，只依靠GIL"></a>1. 不加锁，只依靠GIL</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addNum</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">500000</span>):</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> _ % <span class="number">50000</span>:</span><br><span class="line">            print(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addNum2</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">500000</span>):</span><br><span class="line">        num += <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> _ % <span class="number">50000</span>:</span><br><span class="line">            print(i, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 1 1 0 0 2 2 2 2 2 2 2 1 1 0 0 0 1 1 1 2 2 2 3 3 3 3 1 1 1 3 3 3 3 </span><br><span class="line">3 3 4 4 4 4 4 4 5 5 5 4 4 5 5 5 6 6 6 5 5 4 4 6 5 5 7 7 7 7 7 7 7 7 6 6 6 8 </span><br><span class="line">8 8 6 6 6 7 7 9 9 8 8 8 9 9 9 9 10 10 10 10 9 9 9 10 9 11 10 10 10 8 8 8 10 </span><br><span class="line">10 12 11 11 11 8 13 13 13 11 11 11 13 13 13 11 11 13 13 11 13 13 12 12 12 12</span><br><span class="line">12 12 12 14 14 14 14 12 12 14 14 14 15 15 14 15 15 14 14 15 15 15 15 16 16 16</span><br><span class="line">16 16 17 17 17 17 15 15 16 16 16 16 16 17 17 18 18 17 17 17 17 18 18 18 18 </span><br><span class="line">19 19 19 18 18 19 19 19 19 19 19 18 18 19 </span><br><span class="line">num:  28476988</span><br></pre></td></tr></table></figure>
<p>输出2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 1 1 1 1 0 0 1 1 1 0 0 0 1 1 1 0 2 2 2 2 2 2 2 2 3 3 3 3 2 2 3 3 3 4 4 </span><br><span class="line">4 3 4 4 3 3 5 5 5 5 5 5 5 4 5 5 5 4 4 6 6 6 6 4 4 7 7 7 6 6 6 6 6 7 7 8 8 8 8 </span><br><span class="line">6 8 8 8 8 8 7 7 7 8 7 7 9 9 9 9 9 10 10 9 9 10 10 10 11 11 9 9 9 10 10 10 10 </span><br><span class="line">11 11 11 11 12 12 12 12 11 11 11 11 12 12 10 12 12 12 12 13 13 13 13 13 13 13 </span><br><span class="line">14 14 14 14 14 13 13 14 14 14 14 15 15 15 15 13 14 15 15 15 15 15 15 16 16 16 </span><br><span class="line">16 16 16 17 17 17 17 16 16 16 16 17 17 17 17 17 17 18 18 18 18 18 18 18 18 18 </span><br><span class="line">19 19 19 19 18 19 19 19 19 19 19 </span><br><span class="line">num:  37140187</span><br></pre></td></tr></table></figure>
<p>发现问题了吗？  </p>
<p>全局变量num经过500000次<code>+1</code>和500000次<code>+10</code>，正确的结果应该是55000000才对，但是这两次num的计算结果都无法达到55000000。为什么呢？正是因为GIL的缺陷。首先，GIL锁的颗粒大小为原子操作，即只能保证同一时刻只有一条bytecode的执行，在运行了5毫秒后便强制打断当前线程以切换线程操作。</p>
<p>我们使用dis模块来看看<code>num += 1</code>操作的bytecode:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">tryFunc</span>():</span></span><br><span class="line">        <span class="keyword">global</span> num</span><br><span class="line">        num += <span class="number">1</span>    </span><br><span class="line">    dis.dis(tryFunc)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10           0 LOAD_GLOBAL              0 (num) </span><br><span class="line">              2 LOAD_CONST               1 (1)   </span><br><span class="line">              4 INPLACE_ADD</span><br><span class="line">              6 STORE_GLOBAL             0 (num) </span><br><span class="line">              8 LOAD_CONST               0 (None)</span><br><span class="line">             10 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<p>由此可见num进行+1操作时的原子操作分为四步：</p>
<ol>
<li>将num的值加载到堆栈</li>
<li>将常数1加载到堆栈</li>
<li>将栈顶两元素相加</li>
<li>将相加的值存储回num中</li>
</ol>
<p>如果在GIL默认的5毫秒计时结束时，刚好在第四步前打断了此线程的操作，便会导致<code>num+1</code>的值无法成功存储回num中，使得最后num的结果会比预期值低。在结果中我们可以看到线程的运行顺序大致上是按编号顺序，但其中会有部分编号交错进行，就是因为前一个线程因为运行时间过长被打断。如果一个线程所需要的时间足够短（计算量小），能够在线程被打断之前结束，则num的结果不会受到影响。</p>
<p>为了防止应该连续执行的原子操作被打断，我们需要引入锁。</p>
<h3 id="2-只在循环内将计算操作加锁"><a href="#2-只在循环内将计算操作加锁" class="headerlink" title="2. 只在循环内将计算操作加锁"></a>2. 只在循环内将计算操作加锁</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addNum</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">500000</span>):</span><br><span class="line">        <span class="comment">#获得锁</span></span><br><span class="line">        lock.acquire()</span><br><span class="line"></span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> _ % <span class="number">50000</span>:</span><br><span class="line">            print(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#释放锁</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addNum2</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">500000</span>):</span><br><span class="line">        <span class="comment">#获得锁</span></span><br><span class="line">        lock.acquire()      </span><br><span class="line"></span><br><span class="line">        num += <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> _ % <span class="number">50000</span>:</span><br><span class="line">            print(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#释放锁</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 2 3 4 5 6 7 8 9 10 12 13 11 14 15 18 17 16 19 0 1 17 9 15 8 3 5 16 11 7 </span><br><span class="line">2 13 6 10 19 4 12 18 14 0 1 17 9 8 15 3 11 13 5 16 6 7 12 2 10 19 4 18 0 14 1 </span><br><span class="line">15 9 17 8 12 11 3 4 13 7 0 16 5 19 2 6 14 10 18 1 15 9 17 8 11 3 12 13 4 0 5 </span><br><span class="line">16 7 19 6 2 14 10 18 1 15 9 17 8 11 3 13 12 0 5 4 16 7 19 2 6 10 14 18 1 15 9 </span><br><span class="line">17 8 3 11 13 5 0 7 16 12 4 19 2 6 10 14 18 1 15 17 9 8 3 11 5 13 0 7 16 12 4 </span><br><span class="line">19 2 6 10 14 18 1 15 17 9 8 11 3 13 5 7 16 12 19 4 2 6 10 14 18 1 15 17 9 8 3 </span><br><span class="line">11 13 5 16 7 12 19 2 4 6 10 14 18</span><br><span class="line">num:  55000000</span><br></pre></td></tr></table></figure>

<p>可以看见，num的最后结果终于符合预期了，因为锁保证了在锁释放之前别的线程无法使用全局变量num。</p>
<p>同时需要注意的一点是，这里的锁在<code>acquire()</code>后不受sleep的影响，只能在被<code>release()</code>之后才能被其他线程所使用，因此如果在线程持有锁的过程中sleep，因为别的线程无法获得num的使用权，线程也不会主动让出执行权，只会在此线程内阻塞至sleep定时器结束。这样虽然降低了效率，但保证了颗粒度大于原子操作的线程安全。</p>
<p>但在输出中我们还会发现另一个问题。虽然num最后的结果正确了，但是线程的执行顺序完全被打乱了。我们无法保证num的+1和+10操作是按固定顺序依次进行的，甚至每一次的运行结果都会有所区别。</p>
<p>这是因为我们将锁加在了线程的for循环内。于是每一轮循环结束后，全局变量num就会重新变成所有线程按优先级抢夺的对象。因为每个线程每一轮的运行时间不会完全相同，导致了优先级的改变的随机性，最终导致累加操作无法按照我们预期的顺序进行。</p>
<p>解决方法就是将锁加在循环外，每一个循环完整执行完后才会释放锁。</p>
<h3 id="3-在循环外加锁"><a href="#3-在循环外加锁" class="headerlink" title="3. 在循环外加锁"></a>3. 在循环外加锁</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#lock的acquire()和release()可以被用作with语句的上下文管理器。</span></span><br><span class="line"><span class="comment">#当进入语句块时acquire()方法会被调用，退出语句块时 release()会被调用。</span></span><br><span class="line"><span class="comment">#也就相当于在语句前获得锁，在语句结束时释放锁。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addNum</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">500000</span>):</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> _ % <span class="number">50000</span>:</span><br><span class="line">                print(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addNum2</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">500000</span>):</span><br><span class="line">            num += <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> _ % <span class="number">50000</span>:</span><br><span class="line">                print(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            </span><br></pre></td></tr></table></figure>


<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 4 </span><br><span class="line">4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 8 8 </span><br><span class="line">8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 9 10 10 10 10 10 10 10 10 10 10 11 11 11 11 11 </span><br><span class="line">11 11 11 11 11 12 12 12 12 12 12 12 12 12 12 13 13 13 13 13 13 13 13 13 13 14 14 </span><br><span class="line">14 14 14 14 14 14 14 14 15 15 15 15 15 15 15 15 15 15 16 16 16 16 16 16 16 16 16 </span><br><span class="line">16 17 17 17 17 17 17 17 17 17 17 18 18 18 18 18 18 18 18 18 18 19 19 19 19 19 19 </span><br><span class="line">19 19 19 19</span><br><span class="line">num:  55000000</span><br></pre></td></tr></table></figure>

<p>此时的结果即是多个线程按顺序执行，并且保证了线程安全的结果。在加锁的情况下，线程不会被GIL强制打断，而会一直执行到线程释放锁为止。</p>
</div><div class="tags"><a href="/tags/python/"><i class="fa fa-tag"></i>python</a></div><div class="post-nav"><a class="pre" href="/2021/01/10/Python%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%9C%A8%E5%87%BD%E6%95%B0%E5%86%85%E5%A4%96%E9%83%A8%E7%9A%84%E5%85%B3%E7%B3%BB/">Python全局变量、局部变量在函数内外部的关系</a><a class="next" href="/2020/10/30/python%E5%AE%9E%E7%8E%B0%E5%AF%B9%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%9A%84LS%E7%AE%97%E6%B3%95/">python实现对网络图的LS算法</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/python/" style="font-size: 15px;">python</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/Python%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%9C%A8%E5%87%BD%E6%95%B0%E5%86%85%E5%A4%96%E9%83%A8%E7%9A%84%E5%85%B3%E7%B3%BB/">Python全局变量、局部变量在函数内外部的关系</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/12/CPython%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81GIL%E4%B8%8E%E9%94%81/">CPython中的多线程、GIL与锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/30/python%E5%AE%9E%E7%8E%B0%E5%AF%B9%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%9A%84LS%E7%AE%97%E6%B3%95/">python实现对网络图的LS算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/26/Linux-%E6%80%BB%E7%BB%93-1/">Linux 总结(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/26/MySQL-%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93-1/">MySQL 语句总结(1)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">哪吒的莲花座.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>